"""This module handles the block validation.

Not covered by this module:
- whether a block is generated by the correct admission node. This is covered by the FullCient.
"""

from Crypto.PublicKey import RSA
import logging
from time import time
from hashlib import sha256

from blockchain.helper.cryptography import verify
from blockchain.config import CONFIG
from blockchain.chain import Chain

logger = logging.getLogger("block-validator")


def validate_block(block, previous_block):
    """Validate correctness of block by defined rules.

    This module doesn't check if there are transactions since the demo will generate blocks without transactions.
    """
    if not previous_block:
        return False

    # Index is incremented by 1
    if block.index != previous_block.index + 1:
        logger.info("Wrong index, block index {}, index of last block {}"
                    .format(block.index, previous_block.index))
        return False

    # New block references old one
    if block.previous_block != previous_block.hash:
        logger.info(("New block does not reference previous one, block hash"
                     " {}, hash of last block {}")
                    .format(block.hash, previous_block.hash))
        return False

    # Matching versions
    if block.version != CONFIG["version"]:
        logger.info("Different versions, block version {}, chain version {}"
                    .format(block.version, CONFIG["version"]))
        return False

    # Timestamp not in the future
    if block.timestamp > int(time()):
        logger.info("Timestamp of the new block is in the future")
        return False

    # Valid signature
    content_to_sign = str.encode(block._get_content_for_signing())
    signature = bytes.fromhex(block.signature)
    public_key = RSA.importKey(block.public_key)
    valid = verify(content_to_sign, signature, public_key)
    if not valid:
        logger.info("Signature is not valid, block must be altered")
        return False

    # Check if all transactions are valid
    admissions, doctors, vaccines = Chain().get_registration_caches_by_blockhash(block.previous_block)
    for transaction in block.transactions:
        if not transaction.validate(admissions, doctors, vaccines):
             logger.info("Block contains invalid transactions")
             return False

    # Block has no transactions
    # if len(block.transactions) == 0:
    #     logger.info("Block does not contain any transaction")
    #     return False

    # Number of transactions exceeds the maximum
    if len(block.transactions) > CONFIG["block_size"]:
        logger.info("Too many transactions, block has {}, maximum is {}"
                    .format(len(block.transactions), CONFIG["block_size"]))
        return False

    # Duplicate transactions
    distinct_transactions = len(set([repr(tx) for tx in block.transactions]))
    if len(block.transactions) > distinct_transactions:
        logger.info("Block contains duplicate transactions")
        return False

    # Block hash valid
    content_to_hash = block.get_content_for_hashing()
    sha = sha256()
    sha.update(content_to_hash.encode("utf-8"))
    if block.hash != sha.hexdigest():
        logger.info("Hash is not valid, block must be altered")
        return False

    return True
